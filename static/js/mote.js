// Generated by CoffeeScript 1.3.3
(function() {
  var API, G, S, collision, distance, mass, mass2, overlaps, sort2, sort_by2, _, _ref;

  _ref = typeof exports !== "undefined" && exports !== null ? [exports._mote = {}, require('underscore'), (require('./geom'))._geom, (require('./strains'))._strains.list] : [window._mote = {}, window._, window._geom, window._strains.list], API = _ref[0], _ = _ref[1], G = _ref[2], S = _ref[3];

  sort2 = function(a, b) {
    if (a > b) {
      return [b, a];
    } else {
      return [a, b];
    }
  };

  sort_by2 = function(a, b, f) {
    if ((f(a)) > (f(b))) {
      return [b, a];
    } else {
      return [a, b];
    }
  };

  API.fun_mass = function(r) {
    return r * r * G.pi;
  };

  API.fun_mass_inv = function(m) {
    return Math.sqrt(m / G.pi);
  };

  distance = function(mote, other) {
    return G.distance(mote.x, mote.y, other.x, other.y);
  };

  mass = function(mote) {
    return API.fun_mass(mote.radius);
  };

  mass2 = function(mote, other) {
    return [mass(mote), mass(other)];
  };

  API.collide_with_view = function(mote, bounce) {
    var d, r, vx, vy, x, y;
    if (bounce == null) {
      bounce = true;
    }
    x = mote.x, y = mote.y, vx = mote.vx, vy = mote.vy, r = mote.radius;
    if (0 > (d = x - r)) {
      mote.x -= d;
      if (bounce) {
        mote.vx *= -1;
      }
    } else if (0 > (d = 1 - x - r)) {
      mote.x += d;
      if (bounce) {
        mote.vx *= -1;
      }
    }
    if (0 > (d = y - r)) {
      mote.y -= d;
      if (bounce) {
        return mote.vy *= -1;
      }
    } else if (0 > (d = 1 - y - r)) {
      mote.y += d;
      if (bounce) {
        return mote.vy *= -1;
      }
    }
  };

  API.displace = function(mote, t) {
    mote.x += mote.vx * t;
    return mote.y += mote.vy * t;
  };

  overlaps = function(mote, other) {
    var dist, sum_r;
    dist = distance(mote, other);
    sum_r = mote.radius + other.radius;
    if (dist < sum_r) {
      return [dist, sum_r - dist];
    } else {
      return false;
    }
  };

  API.collide_mote = function(mote, motes) {
    var others;
    others = _.sortBy(_.reject(motes, function(other) {
      return other === mote || !overlaps(mote, other);
    }), 'radius');
    if (!(others.length < 1)) {
      return collision(mote, others.pop());
    }
  };

  collision = function(mote, other) {
    var d, dm, loser, m0, m0_, m1, m1_, r0, r1, sum_mass, winner, _ref1, _ref2, _ref3, _ref4, _ref5;
    _ref1 = sort_by2(mote, other, function(m) {
      return m.radius;
    }), loser = _ref1[0], winner = _ref1[1];
    d = distance(loser, winner);
    _ref2 = mass2(loser, winner), m0 = _ref2[0], m1 = _ref2[1];
    sum_mass = m0 + m1;
    r0 = 1 / 2 * (d + Math.sqrt(2 * sum_mass / G.pi - d * d));
    r1 = d - r0;
    if (r1 < 0) {
      _ref3 = [0, API.fun_mass_inv(sum_mass)], r1 = _ref3[0], r0 = _ref3[1];
    }
    _ref4 = sort2(r0, r1), loser.radius = _ref4[0], winner.radius = _ref4[1];
    _ref5 = mass2(loser, winner), m0_ = _ref5[0], m1_ = _ref5[1];
    dm = m0 - m0_;
    winner.vx = (m1 * winner.vx + dm * loser.vx) / m1_;
    return winner.vy = (m1 * winner.vy + dm * loser.vy) / m1_;
  };

  API.eject = function(i, strain, motes, angle) {
    var dm, dmote, dr, dx, dy, m0, m0_, mote, r0, r0_, vx0, vy0, x0, y0, _ref1;
    mote = (_.where(motes, {
      strain: strain
    }))[i];
    x0 = mote.x, y0 = mote.y, vx0 = mote.vx, vy0 = mote.vy, r0 = mote.radius;
    if (r0 < 0.03) {
      return;
    }
    m0 = API.fun_mass(r0);
    dm = 0.02 * m0;
    if (angle < 0) {
      angle += G.pi;
    }
    _ref1 = [Math.cos(angle), Math.sin(angle)], dx = _ref1[0], dy = _ref1[1];
    dr = API.fun_mass_inv(dm);
    m0_ = m0 - dm;
    r0_ = API.fun_mass_inv(m0_);
    dmote = {
      strain: mote.strain,
      radius: dr,
      x: x0 + dx * 1.1 * (dr + r0_),
      y: y0 + dy * 1.1 * (dr + r0_),
      vx: 0.5 * dx,
      vy: 0.5 * dy
    };
    mote.radius = r0_;
    mote.vx = (m0 * vx0 - dm * dmote.vx) / m0_;
    mote.vy = (m0 * vy0 - dm * dmote.vy) / m0_;
    return motes.push(dmote);
  };

}).call(this);
